/*
 * LiquidBounce+ Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/WYSI-Foundation/LiquidBouncePlus/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.features.module.modules.movement.LongJump
import net.ccbluex.liquidbounce.features.module.modules.exploit.helper.PacketThread
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.handshake.client.C00Handshake
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.*
import io.netty.buffer.Unpooled
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import net.minecraft.world.WorldSettings.GameType

import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.util.LinkedList

import kotlin.math.sqrt
import kotlin.math.round

@ModuleInfo(name = "Disabler", description = "Disable some anticheats' checks.", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {

    private val modeValue = ListValue("Mode", 
        arrayOf(
            "Basic", // cancel c0f and c00
            "FakeLag", // use a packet bus
            "FakeLag2", // use threads to wait and then send packet async
            "SpartanCombat", // old spartan combat disabler
            "OldMatrix", // work with old matrix, around 5.2.x
            "OldGhostly", // self-explanation
            "Kauri", // kauri
            "Riding", // spoof c0c packet with real player data
            "Spectate", // spoof c18 with player uid
            "OldVerus", // Dort
            "OldHypixel", // Someone named LX sent me this mode in Discord. Very appreciate his support. (It's actually someone else code that I won't say here)
            "Verus" // my own verus disabler version
        ), "Basic")

    private val minRand: IntegerValue = object : IntegerValue("FakeLag-MinDelay", 0, 0, 20000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxRand.get()
            if (v < newValue) set(v)
        }
    }
    private val maxRand: IntegerValue = object : IntegerValue("FakeLag-MaxDelay", 0, 0, 20000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minRand.get()
            if (v > newValue) set(v)
        }
    }

    private val fakelagStrafe = BoolValue("FakeLag-StrafeDisabler", true)

    // Verus
    private val verusDelayMode = ListValue("Verus-DelayMode", arrayOf("PlayerTick", "System", "Dynamic"), "System")
    private val verusTickDelay = IntegerValue("Verus-TickDelay", 120, 0, 240)
    private val verusSystemDelay = IntegerValue("Verus-SystemDelay", 310, 0, 10000)
    private val verusTPTickDelay = IntegerValue("Verus-TeleportTickDelay", 80, 0, 240)
    private val verusDupe = IntegerValue("Verus-TransactionDupe", 6, 0, 100)
    private val verusDynamicDupe = BoolValue("Verus-DynamicDupe", false)
    private val verusActionDelay = IntegerValue("Verus-ServerJoinDelay", 0, 0, 240)
    private val verusc0c = BoolValue("Verus-RidingSpoof", false)
    private val verusc0cA = BoolValue("Verus-RidingSpoofAdv", false)
    private val verusAntiBan = BoolValue("Verus-AntiBan", false)
    private val verusCombat = BoolValue("Verus-CombatTest", false)
    private val verusSilent = BoolValue("Verus-SilentSetback", false)
    private val verusNofall = BoolValue("Verus-Nofall", false)
    private val verusBusMinSize = IntegerValue("Verus-Bus-MinSize", 0, 0, 240)

    private val debugValue = BoolValue("Debug", false)

    private val keepAlives = arrayListOf<C00PacketKeepAlive>()
    private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
    private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
    private val anotherQueue = LinkedList<C00PacketKeepAlive>()

    private val packetBus = hashMapOf<Long, Packet<INetHandlerPlayServer>?>()
    
    private val msTimer = MSTimer()

    private var dState = 0
    private var sendYModify = false

    private var dynamicDelay = 0
    private var lastReceive: Long = 0L

    fun debug(s: String) {
        if (debugValue.get())
            ClientUtils.displayChatMessage("§7[§3§lDisabler§7]§f $s")
    }

    override fun onEnable() {
        keepAlives.clear()
        transactions.clear()
        packetQueue.clear()
        anotherQueue.clear()
        packetBus.clear()

        msTimer.reset()
        dState = 0
        dynamicDelay = verusSystemDelay.get()
        sendYModify = false
    }

    override fun onDisable() {
        keepAlives.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }
        transactions.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }

        keepAlives.clear()
        transactions.clear()
        packetQueue.clear()
        anotherQueue.clear()
        packetBus.clear()

        msTimer.reset()

        mc.thePlayer.motionY = 0.0
        MovementUtils.strafe(0F)
        mc.timer.timerSpeed = 1F
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
    
        when (modeValue.get().toLowerCase()) {
            "oldmatrix" -> if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
                try {
                    val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF(mc.thePlayer.gameProfile.getName())
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))
                } catch (e: IOException) {

                }
            }
            "kauri" -> if (packet is C0FPacketConfirmTransaction) event.cancelEvent()
            "riding" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
            "basic" -> if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
            "oldghostly" -> {
                if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput())
                if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
            }
            "spartancombat" -> {
                if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
                    keepAlives.add(packet)
                    event.cancelEvent()
                }
                if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
                    transactions.add(packet)
                    event.cancelEvent()
                }
            }
            "spectate" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
            "oldverus" -> {
                /*if (mc.thePlayer != null && mc.thePlayer.ticksExisted == 0)
                    packetQueue.clear()

                    not really necessary since the clear implementation was added below
                */

                if (packet is C03PacketPlayer) {
                    val yPos = round(mc.thePlayer.posY / 0.015625) * 0.015625
                    mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)

                    if (mc.thePlayer.ticksExisted % 45 == 0) {
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 11.725, mc.thePlayer.posZ, false))
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    }
                }

                if (packet is S08PacketPlayerPosLook) {
                    if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                    var x = packet.getX() - mc.thePlayer.posX
                    var y = packet.getY() - mc.thePlayer.posY
                    var z = packet.getZ() - mc.thePlayer.posZ
                    var diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), true))
                    }
                }

                if (packet is C0FPacketConfirmTransaction) {
                    repeat (4) {
                        packetQueue.add(packet)
                    }
                    event.cancelEvent()
                }
            }
            "oldhypixel" -> {
                if (packet is C0FPacketConfirmTransaction)
                {
                    repeat (4) {
                        transactions.add(packet)
                    }
                    event.cancelEvent()
                    debug("duped transaction 4x.")
                }

                if (mc.thePlayer.ticksExisted > 100) {
                    if (transactions.size > 30) {
                        transactions.forEach { 
                            try {
                                PacketUtils.sendPacketNoEvent(it) 
                            } catch (e: Exception) {
                                // ignore, fix errors spamming the log.
                            }
                        }
                        transactions.clear()
                        debug("Flushed transactions queue.")
                        if (dState == 0) dState++
                    }
                } else if (mc.thePlayer == null || mc.thePlayer.ticksExisted < 100) {
                    transactions.clear()
                    dState = 0
                }

                if (dState == 1) {
                    LiquidBounce.hud.addNotification(Notification("","You may be able to use some features now.", NotifyType.SUCCESS, 5000L))
                    dState++
                }
            }
            "fakelag" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    debug("transferred a c0f to packet bus")
                    packetBus.put((System.currentTimeMillis() + RandomUtils.nextInt(minRand.get(), maxRand.get())).toLong(), packet)
                    event.cancelEvent()
                }
                
                if (packet is C00PacketKeepAlive) {
                    debug("transferred a c00 to packet bus")
                    packetBus.put((System.currentTimeMillis() + RandomUtils.nextInt(minRand.get(), maxRand.get())).toLong(), packet)
                    event.cancelEvent()
                }
            }
            "fakelag2" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    debug("start c0f packet thread")
                    PacketThread(packet, RandomUtils.nextInt(minRand.get(), maxRand.get()).toLong(), true).start()
                    event.cancelEvent()
                }
                
                if (packet is C00PacketKeepAlive) {
                    debug("start c00 packet thread")
                    PacketThread(packet, RandomUtils.nextInt(minRand.get(), maxRand.get()).toLong(), true).start()
                    event.cancelEvent()
                }
            }
            "verus" -> {
                if (mc.thePlayer == null || mc.theWorld == null || mc.thePlayer.ticksExisted <= verusActionDelay.get()) return
                if (packet is C0FPacketConfirmTransaction) {
                    if (lastReceive != 0L)
                    {
                        dynamicDelay = (System.currentTimeMillis() - lastReceive).toInt()
                        //if (verusDelayMode.get().equals("dynamic", true)) debug("dynamic: ${dynamicDelay}ms")
                    }
                    lastReceive = System.currentTimeMillis()

                    debug("c0f, uid ${packet.uid}, window id ${packet.windowId}")

                    if (verusAntiBan.get()) {
                        packet.windowId = 65536
                        packet.uid = 32767
                    }

                    val dupeAmount = if (verusDynamicDupe.get()) (dynamicDelay.toDouble() / 50.0).toInt() else verusDupe.get()
                    repeat (dupeAmount) {
                        packetQueue.add(packet)
                    }

                    debug("dupe transaction $dupeAmount times.")

                    event.cancelEvent()
                }
                if (packet is C00PacketKeepAlive) {
                    if (verusCombat.get())
                        packet.key -= RandomUtils.nextInt(1000, 2147483647)
                }
                if (packet is C03PacketPlayer) {
                    if (verusNofall.get()) {
                        val yPos = round(mc.thePlayer.posY / 6.25E-4) * 6.25E-4
                        packet.y = yPos
                        packet.onGround = true
                    }

                    if (mc.thePlayer.ticksExisted % verusTickDelay.get() == 0) {
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(packet.x, packet.y, packet.z, packet.onGround))
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(packet.x, packet.y - 11.625, packet.z, false)) 
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, mc.thePlayer.onGround))

                        debug("flag")
                    }

                    if (verusc0c.get()) { // ????? wtf am i doing
                        PacketUtils.sendPacketNoEvent(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, true, mc.thePlayer.movementInput.sneak))
                       if (verusc0cA.get()) { PacketUtils.sendPacketNoEvent(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.RIDING_JUMP))
                        

                        val lastGameType = mc.playerController.getCurrentGameType()
                        mc.playerController.setGameType(GameType.SPECTATOR)
                        PacketUtils.sendPacketNoEvent(C18PacketSpectate(mc.thePlayer.uniqueID))
                        PacketUtils.sendPacketNoEvent(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                        mc.playerController.setGameType(lastGameType)}
                    }
                }

                if (packet is S08PacketPlayerPosLook) {
                    if (!verusSilent.get())
                        return
                    // in some servers, if you cancel s08 too early then you wont get into the ingame gui, resulting in stuck.
                    var x = packet.getX() - mc.thePlayer.posX
                    var y = packet.getY() - mc.thePlayer.posY
                    var z = packet.getZ() - mc.thePlayer.posZ
                    var diff = sqrt(x * x + y * y + z * z)
                    if (diff < 8) { //may cause the player to desync from server side.
                        event.cancelEvent()
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false)) // idk why, just copy vanilla packet handling
                    }
                }
            }
        }
    }

/*    @EventTarget
    fun onMotion(event: MotionEvent) {
        val speed = LiquidBounce.moduleManager.getModule(Speed::class.java)!!
        val lj = LiquidBounce.moduleManager.getModule(LongJump::class.java)!!
        if ((modeValue.get().equals("oldhypixel", true) || ((modeValue.get().equals("fakelag", true) || modeValue.get().equals("fakelag2", true)) && fakelagStrafe.get())) && mc.thePlayer.onGround && (speed.state || lj.state)) {
            if (!sendYModify) {
                event.y += .004 * Math.random()
                debug("Sent Y offset.")
                sendYModify = true
            }
        } else
            sendYModify = false
    }*/

    @EventTarget
    fun onWorld(event: WorldEvent) {
        transactions.clear()
        keepAlives.clear()
        packetQueue.clear()
        anotherQueue.clear()
        packetBus.clear()

        msTimer.reset()
        dState = 0
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        when (modeValue.get().toLowerCase()) {
            "spartancombat" -> {
                if (msTimer.hasTimePassed(3000L) && keepAlives.size > 0 && transactions.size > 0) {
                    PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
                    PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])
                    keepAlives.clear()
                    transactions.clear()
                    msTimer.reset()
                }
            }
            "oldverus" -> {
                if (mc.thePlayer.ticksExisted % 180 == 0) {
                    while (packetQueue.size > 22) {
                        PacketUtils.sendPacketNoEvent(packetQueue.poll())
                    }
                }
            }
            "verus" -> {
                if (packetQueue.size > verusBusMinSize.get() || mc.thePlayer == null || mc.theWorld == null) 
                {
                    msTimer.reset() // make sure to reset it
                    return
                }

                if (verusDelayMode.get().equals("playertick", true)) {
                    if (mc.thePlayer.ticksExisted % verusTickDelay.get() == 0) {
                        try {
                            val packet: C0FPacketConfirmTransaction = packetQueue.poll()
                            PacketUtils.sendPacketNoEvent(packet)
                            debug("poll transaction packet at tick ${mc.thePlayer.ticksExisted}. uid ${packet.uid}, windowId ${packet.windowId}.")
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                } else {
                    val timerDelay = if (verusDelayMode.get().equals("dynamic", true)) dynamicDelay else verusSystemDelay.get()
                    if (msTimer.hasTimePassed(timerDelay.toLong())) {
                        try {
                            val packet: C0FPacketConfirmTransaction = packetQueue.poll()
                            PacketUtils.sendPacketNoEvent(packet)
                            debug("poll transaction packet, rate: ${timerDelay}ms. uid ${packet.uid}, windowId ${packet.windowId}.")
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                        msTimer.reset()
                    }
                }
            }
            "fakelag" -> {
                try {
                    val iter = packetBus.keys.iterator()
                    while (iter.hasNext()) {
                        val time = iter.next()
                        val packet = packetBus[time]
                        val packetType = if (packet is C0FPacketConfirmTransaction) "c0f" else "c00"
                        if (System.currentTimeMillis() >= time) {
                            PacketUtils.sendPacketNoEvent(packet)
                            debug("$packetType push! ($time)")
                            iter.remove()
                        }
                    }
                } catch (e: Exception) {
                    // ignore
                }
            }
        }
    }
}